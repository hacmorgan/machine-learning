#!/usr/bin/env python

import numpy as np
import math
import argparse
import sys
import time
import json

img_width = 64
img_height = 48

def cost(y, h, lmbda, theta1, theta2):
    m = len(y)
    return (
        1.0/m * np.sum( -y * np.log(h) - (1 - y) * np.log(1-h) ) +
        float(lmbda)/(2*m) *  (np.sum(theta1[1:,:] ** 2) + np.sum(theta2[1:,:] ** 2))
    )

def theta_grads(X, y, lmbda, theta1, theta2):
    # initialisation
    m = len(y)
    theta1_grad = np.zeros(np.shape(theta1))
    theta2_grad = np.zeros(np.shape(theta2))
    # forwardprop
    X = np.concatenate( (np.ones((m,1)),X), axis=1)
    z1 = np.matmul(X, theta1)
    a1 = np.concatenate((np.ones((m,1)),sigmoid(z1)), axis=1)
    z2 = np.matmul(a1, theta2)
    a2 = sigmoid(z2)
    # backprop
    delta2 = a2 - y
    theta2_grad = 1.0/m * np.matmul(a1.transpose(), delta2)
    delta1 = np.matmul(delta2, theta2[1:,:].transpose()) * sigmoid_gradient(z1)
    theta1_grad = 1.0/m * np.matmul(X.transpose(), delta1)
    theta2_reg = lmbda/m * theta2
    theta2_reg[0,:] = 0
    theta2_grad += theta2_reg
    theta1_reg = lmbda/m * theta1
    theta1_reg[0,:] = 0
    theta1_grad += theta1_reg
    return theta1_grad, theta2_grad

def sigmoid(z):
    return 1.0 / (1.0 + np.exp(-z))

def sigmoid_gradient(z):
    return sigmoid(z) * (1 - sigmoid(z))

def fwd_prop(X, theta1, theta2):
    m = len(X)
    X = np.concatenate( (np.ones((m,1)),X), axis=1)
    z1 = np.matmul(X, theta1)
    a1 = np.concatenate((np.ones((m,1)),sigmoid(z1)), axis=1)
    z2 = np.matmul(a1, theta2)
    return sigmoid(z2)

def initialise_weights(theta1_dims, theta2_dims):
    theta1 = np.random.normal(loc=0, scale=(1/math.sqrt(theta1_dims[0])), size=theta1_dims)
    theta2 = np.random.normal(loc=0, scale=(1/math.sqrt(theta2_dims[0])), size=theta2_dims)
    return theta1, theta2

def get_data(filename):
    with open(filename, "rb") as datafile:
        all_data = np.frombuffer(datafile.read(), dtype=np.uint8)
    all_data = all_data.astype(np.float32)
    num_records = int(np.shape(all_data)[0] / (img_height*img_width+1))
    formatted_data = all_data.reshape((num_records, img_height*img_width+1))
    scaling_matrix = np.ones(formatted_data.shape, dtype = np.float32) * 255
    scaling_matrix[:,-1] = 1
    formatted_data /= scaling_matrix
    return formatted_data

def get_args():
    parser = argparse.ArgumentParser(description='train a simple 3 layer neural network on given data')
    parser.add_argument('--training-data', '-t', type=str, required=True, help='file containing training data')
    return parser.parse_args()

def sgd(full_data, lmbda, eta, epochs, theta1, theta2):
    # we will designate the last 10% of data to be training data
    np.random.shuffle(full_data)
    cutoff_point = int(0.9 * len(full_data))
    training_data = full_data[:cutoff_point, :]
    test_data = full_data[cutoff_point:, :]
    X_test = test_data[:,:-1]
    y_test = test_data[:,-1].reshape((len(full_data)-cutoff_point,1))
    m = len(training_data)
    train_costs = []
    test_costs = []
    for i in range(epochs):
       np.random.shuffle(training_data)
       X = training_data[:,:-1]
       y = training_data[:,-1].reshape((cutoff_point,1))
       theta1_grad, theta2_grad = theta_grads(X, y, lmbda, theta1, theta2)
       # update weights
       theta1 = theta1 - eta/m * theta1_grad
       theta2 = theta2 - eta/m * theta2_grad
       train_costs.append(cost(y, fwd_prop(X, theta1, theta2), lmbda, theta1, theta2))
       test_costs.append(cost(y_test, fwd_prop(X_test, theta1, theta2), lmbda, theta1, theta2))
       test_accuracy(X_test, y_test, theta1, theta2)
       print("Epoch no. " + str(i) + " gave training cost: " + str(train_costs[-1]) + " and test cost: " + str(test_costs[-1]) + "\n")
       # time.sleep(0.05)
    return theta1, theta2

def test_accuracy(X_test, y_test, theta1, theta2):
    h = fwd_prop(X_test, theta1, theta2)
    num_examples = len(h)
    perc_correct = np.sum( (y_test-np.round(h)) ** 2 ) / num_examples
    print("Correctly classified " + str(int((1-perc_correct) * num_examples)) +
          " out of " + str(num_examples) + " examples, which is an accuracy of " +
          str((1-perc_correct) * 100) + "%")
        

def main(args):
    # tweakable params
    hidden_units = 30
    lmbda = 1
    eta = 3
    epochs = 800
    # initialise thetas and get X and y from the data
    theta1, theta2 = initialise_weights((img_width*img_height+1, hidden_units), (hidden_units+1, 1))
    full_data = get_data(args.training_data)
    # SGD
    theta1, theta2 = sgd(full_data, lmbda, eta, epochs, theta1, theta2)
    # save params to file
    params = {
        "num_laters" : 3,
        "dimensions" : (theta1.shape, theta2.shape),
        "thetas" : (theta1.tolist(), theta2.tolist())
    }
    save_name = str(int(time.time())) + ".json"
    with open(save_name, "w") as jsonfile:
        json.dump(params, jsonfile)
    return
    
if __name__ == '__main__':
    sys.exit(main(get_args()))
    
